<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockWorld</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont,
               'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  background: #000;
}

        canvas { display: block; }
        
/* Main Menu Styles */
#main-menu {
    position: fixed;
    inset: 0;
    z-index: 1000;
}


#panorama-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

@keyframes panoramaSlide {
    0% { background-position: 0% center; }
    100% { background-position: 100% center; }
}
.menu-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.3);
}

.game-title {
    font-size: 5rem;
    color: white;
    text-shadow: 
        0 0 20px rgba(0, 0, 0, 0.8),
        0 0 40px rgba(100, 200, 255, 0.4);
    margin-bottom: 50px;
    letter-spacing: 4px;
}

.main-buttons {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.menu-btn {
    padding: 18px 80px;
    font-size: 1.3rem;
    background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.4);
    border-radius: 12px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 20px rgba(0,0,0,0.4);
}

.menu-btn:hover {
    background: linear-gradient(145deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
    transform: translateY(-3px);
    box-shadow: 0 12px 30px rgba(0,0,0,0.6);
}

.version-label {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: rgba(255,255,255,0.6);
    font-size: 0.9rem;
}

/* World Selection */
#world-select {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #1e1e1e, #2c2c2c);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.menu-box-large {
    background: rgba(30, 30, 30, 0.95);
    padding: 40px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    color: white;
    backdrop-filter: blur(5px);
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
}

#world-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 20px;
    margin: 30px 0;
    min-height: 200px;
}

.world-card {
    background: rgba(50, 50, 50, 0.8);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 12px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.world-card:hover {
    border-color: rgba(100, 200, 255, 0.6);
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(100, 200, 255, 0.3);
}

.world-card h3 {
    margin: 0 0 10px 0;
    font-size: 1.2rem;
}

.world-card p {
    margin: 5px 0;
    color: #aaa;
    font-size: 0.9rem;
}

.world-card .delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 50, 50, 0.8);
    border: none;
    color: white;
    padding: 5px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.8rem;
}

.world-card .delete-btn:hover {
    background: rgba(255, 30, 30, 1);
}

.menu-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

.menu-actions button {
    padding: 12px 30px;
    font-size: 1.1rem;
}

#create-world, #settings-menu {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #1e1e1e, #2c2c2c);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.menu-box {
    background: rgba(30, 30, 30, 0.95);
    padding: 50px 60px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    text-align: center;
    color: #fff;
    backdrop-filter: blur(5px);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

h1 {
    font-size: 3rem;
    margin-bottom: 25px;
    color: #fff;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
}

input[type="text"] {
    padding: 15px 20px;
    font-size: 1.1rem;
    width: 320px;
    margin-bottom: 25px;
    text-align: center;
    border: none;
    border-radius: 12px;
    outline: none;
    background: #333;
    color: #fff;
    box-shadow: inset 0 4px 6px rgba(0, 0, 0, 0.4);
    transition: background 0.3s ease;
}
/* ───────── Custom Toggle Checkbox ───────── */
.toggle {
    display: flex;
    align-items: center;
    gap: 14px;
    cursor: pointer;
    user-select: none;
}

.toggle input {
    display: none; /* hide real checkbox */
}

/* Track */
.toggle .slider {
    position: relative;
    width: 48px;
    height: 26px;
    background: #333;
    border-radius: 999px;
    box-shadow: inset 0 0 0 2px #555;
    transition: background 0.25s ease, box-shadow 0.25s ease;
}

/* Knob */
.toggle .slider::before {
    content: '';
    position: absolute;
    top: 3px;
    left: 3px;
    width: 20px;
    height: 20px;
    background: #eee;
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6);
    transition: transform 0.25s ease, background 0.25s ease;
}

/* Checked state */
.toggle input:checked + .slider {
    background: linear-gradient(145deg, #6cf, #39f);
    box-shadow: inset 0 0 0 2px #9df;
}

.toggle input:checked + .slider::before {
    transform: translateX(22px);
    background: #fff;
}

/* Label text */
.toggle-label {
    color: #ddd;
    font-size: 1rem;
}


input:focus {
    background: #444;
}

button {
    padding: 15px 45px;
    font-size: 1.2rem;
    cursor: pointer;
    background: linear-gradient(145deg, #555, #333);
    color: #fff;
    border: none;
    border-radius: 12px;
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
    transition: background 0.3s ease, transform 0.2s ease;
}

button:hover {
    background: linear-gradient(145deg, #777, #555);
    transform: translateY(-2px);
}


        #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 32px;
    pointer-events: none;
    text-shadow: 0 0 8px rgba(0,0,0,0.7);
    z-index: 100;
}

.slot {
    width: 64px;
    height: 64px;

    background: linear-gradient(
        145deg,
        rgba(255,255,255,0.16),
        rgba(255,255,255,0.04)
    );

    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);

    border: 1px solid rgba(255,255,255,0.35);
    border-radius: 14px;

    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    font-size: 12px;
    position: relative;
    cursor: pointer;

    box-shadow:
        0 6px 16px rgba(0,0,0,0.45),
        inset 0 1px 0 rgba(255,255,255,0.25);

    transition:
        transform 0.18s ease,
        box-shadow 0.18s ease,
        border-color 0.18s ease,
        background 0.18s ease;
}

.slot:hover {
    transform: translateY(-3px) scale(1.05);
    border-color: rgba(255,255,255,0.6);
    box-shadow:
        0 10px 24px rgba(0,0,0,0.6),
        inset 0 1px 0 rgba(255,255,255,0.35);
}


.slot img {
    width: 45px;
    height: 45px;
}



.slot-count {
    font-size: 16px;
    font-weight: bold;
    position: absolute;
    bottom: 4px;
    right: 6px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}

#info {
    position: fixed;
    top: 10px;
    left: 10px;
    color: #fff;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
    font-size: 14px;
    pointer-events: none;
    z-index: 200; /* ← ADD THIS */
}


#inventory {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);

    /* Glass look */
    background: linear-gradient(
        145deg,
        rgba(255,255,255,0.18),
        rgba(255,255,255,0.06)
    );
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);

    padding: 28px;
    border-radius: 20px;

    border: 1px solid rgba(255,255,255,0.35);

    box-shadow:
        0 20px 40px rgba(0,0,0,0.6),
        inset 0 1px 0 rgba(255,255,255,0.25);

    display: none;
    z-index: 200;
}

#inventory.visible {
    display: block;
    animation: popIn 0.2s ease forwards;
}

#inventory h2 {
    color: white;
    margin-bottom: 22px;
    text-align: center;
    font-weight: 600;
    letter-spacing: 0.5px;
    text-shadow:
        0 2px 4px rgba(0,0,0,0.6);
}

.inv-grid {
    display: grid;
    grid-template-columns: repeat(9, 70px);
    gap: 14px;
}



/* Optional pop-in animation for inventory */
@keyframes popIn {
    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}

    /* ───────── MOBILE UI ───────── */
#mobile-ui {
    position: fixed;
    inset: 0;
    z-index: 999;
    pointer-events: none;
    display: none; /* JS enables it */
    font-family: 'Segoe UI', Roboto, sans-serif;
}

/* Base page styling */
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    touch-action: none;
    background: #111; /* subtle background for mobile */
}

canvas {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    display: block;
}

@media (max-width: 900px) {

    /* ───────── JOYSTICK ───────── */
    #joystick {
        position: absolute;
        left: 20px;
        bottom: 40px;
        width: min(90px, 22vw);
        height: min(90px, 22vw);
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(6px);
        pointer-events: auto;
        z-index: 1000;
        box-shadow: 0 6px 14px rgba(0,0,0,0.5);
    }

    #stick {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255,255,255,0.85);
        transform: translate(-50%, -50%);
        box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        pointer-events: none;
        will-change: transform;
    }

    /* ───────── GLASS BUTTONS ───────── */
    .mobile-btn {
        position: absolute;
        width: min(64px, 14vw);
        height: min(64px, 14vw);
        border-radius: 18px;
        pointer-events: auto;

        background: linear-gradient(
            145deg,
            rgba(255,255,255,0.18),
            rgba(255,255,255,0.05)
        );

        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.35);

        display: flex;
        align-items: center;
        justify-content: center;

        box-shadow:
            0 8px 20px rgba(0,0,0,0.45),
            inset 0 1px 0 rgba(255,255,255,0.25);

    }


.mobile-btn svg {
    display: block;
    flex: 0 0 auto;     /* ← CRITICAL */
    width: 28px;
    height: 28px;
    min-width: 28px;   /* ← CRITICAL */
    min-height: 28px;

    fill: none;
    stroke: white;
    stroke-width: 2.2;
    stroke-linecap: round;
    stroke-linejoin: round;

    pointer-events: none;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,0.6));
}


    /* Button positions */
    #jumpBtn { right: 20px; bottom: 110px; }
    #invBtn  { right: 20px; bottom: 32px; }
}



/* ───────── HUD ───────── */
#hud {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    z-index: 10;
}
#hud .slot {
    width: 50px;
    height: 50px;

    background: linear-gradient(
        145deg,
        rgba(255,255,255,0.18),
        rgba(255,255,255,0.05)
    );

    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);

    border: 1px solid rgba(255,255,255,0.35);
    border-radius: 14px;

    display: flex;
    align-items: center;
    justify-content: center;

    color: #fff;
    font-size: 12px;

    box-shadow:
        0 8px 20px rgba(0,0,0,0.45),
        inset 0 1px 0 rgba(255,255,255,0.25);

    transition:
        transform 0.18s ease,
        box-shadow 0.18s ease,
        border-color 0.18s ease,
        background 0.18s ease;
}

#hud .slot.selected {
    border-color: rgba(21, 255, 0, 0.9);

    background: linear-gradient(
        145deg,
        rgba(0, 255, 64, 0.28),
        rgba(0, 255, 42, 0.12)
    );

    box-shadow:
        0 0 14px rgba(0, 255, 0, 0.85),
        inset 0 0 6px rgba(0, 255, 13, 0.6);

    transform: translateY(-6px) scale(1.1);
}


/* Optional animated pulse */
@keyframes slotPulse {
    0%   { box-shadow: 0 0 8px rgba(0, 255, 64, 0.6); }
    50%  { box-shadow: 0 0 16px rgb(0, 255, 13); }
    100% { box-shadow: 0 0 8px rgba(0, 255, 21, 0.6); }
}

#hud .slot.selected {
    animation: slotPulse 1.4s infinite;
}
.option {
    margin-bottom: 20px;
    color: #ddd;
    font-size: 1rem;
}

.option label {
    display: block;
    margin-bottom: 6px;
    text-align: left;
}

select {
    width: 320px;
    padding: 12px;
    border-radius: 12px;
    border: none;
    background: #333;
    color: #fff;
    font-size: 1rem;
    outline: none;
    box-shadow: inset 0 4px 6px rgba(0,0,0,0.4);
}

select:focus {
    background: #444;
}

.option.checkbox label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
}

.option.checkbox input {
    width: 18px;
    height: 18px;
    accent-color: #6cf;
}
#fps {
    position: fixed;
    top: 10px;
    right: 10px;
    color: #00ff88;
    font-size: 14px;
    font-family: monospace;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
    pointer-events: none;
    z-index: 100;
}
#loading-screen {
    position: fixed;
    inset: 0;
    background: linear-gradient(135deg, #0f0f0f, #1c1c1c);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1001;
    color: white;
    font-family: 'Segoe UI', Roboto, sans-serif;
}
.hidden-ui {
    display: none !important;
}

.loading-bar {
    width: 320px;
    height: 18px;
    background: #333;
    border-radius: 999px;
    overflow: hidden;
    margin: 20px 0 10px;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.6);
}

.loading-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #6cf, #39f);
    transition: width 0.2s ease;
}

#loading-text {
    margin-top: 10px;
    color: #ccc;
}

#loading-percent {
    font-family: monospace;
    margin-top: 6px;
    color: #9df;
}

    </style>

</head>
<body>
<!-- Main Menu -->
<div id="main-menu">
    <canvas id="panorama-canvas"></canvas>
    <div class="menu-overlay">
        <h1 class="game-title">BlockWorld v0.4</h1>
        <div class="main-buttons">
            <button class="menu-btn" onclick="showWorldSelect()">Play</button>
            <button class="menu-btn" onclick="showSettings()">Settings</button>
        </div>
        <div class="version-label">v0.4</div>
    </div>
</div>

<!-- World Selection Screen -->
<div id="world-select" style="display:none;">
    <div class="menu-box-large">
        <h1>Select World</h1>
        <div id="world-list"></div>
        <div class="menu-actions">
            <button onclick="showCreateWorld()">Create New World</button>
            <button onclick="showMainMenu()">Back</button>
        </div>
    </div>
</div>

<!-- Create World Screen -->
<div id="create-world" style="display:none;">
    <div class="menu-box">
        <h1>Create New World</h1>

        <input type="text" id="worldName" placeholder="World Name" value="New World">
        <input type="text" id="seed" placeholder="Seed (optional)">

        <div class="option">
            <label for="worldSize">World Size</label>
            <select id="worldSize">
                <option value="30">Small</option>
                <option value="99" selected>Medium</option>
                <option value="160">Large</option>
            </select>
        </div>

        <div class="option">
            <label for="worldType">World Type</label>
            <select id="worldType">
                <option value="normal" selected>Normal</option>
                <option value="flat">Flat</option>
            </select>
        </div>

        <div class="option checkbox">
            <label class="toggle">
                <input type="checkbox" id="floatingIslands">
                <span class="slider"></span>
                <span class="toggle-label">Floating Islands</span>
            </label>
        </div>
        <div class="menu-actions">
            <button onclick="createNewWorld()">Create</button>
            <button onclick="showWorldSelect()">Cancel</button>
        </div>
    </div>
</div>

<!-- Settings Screen -->
<div id="settings-menu" style="display:none;">
    <div class="menu-box">
        <h1>Settings</h1>
        
        <div class="option">
            <label for="renderDistance">Render Distance</label>
            <select id="renderDistance">
                <option value="20">Low (20)</option>
                <option value="30" selected>Medium (30)</option>
                <option value="40">High (40)</option>
                <option value="50">Ultra (50)</option>
            </select>
        </div>

        <div class="option checkbox">
            <label class="toggle">
                <input type="checkbox" id="settingsShadows">
                <span class="slider"></span>
                <span class="toggle-label">Shadows</span>
            </label>
        </div>
        <div class="option checkbox">
    <label class="toggle">
        <input type="checkbox" id="settingsLeavesAlpha">
        <span class="slider"></span>
        <span class="toggle-label">Fancy Leaves</span>
    </label>
</div>
        <div class="option checkbox">
            <label class="toggle">
                <input type="checkbox" id="settingsFPS">
                <span class="slider"></span>
                <span class="toggle-label">Show FPS</span>
            </label>
        </div>

        <div class="menu-actions">
            <button onclick="saveSettings()">Save</button>
            <button onclick="showMainMenu()">Back</button>
        </div>
    </div>
</div>
    
<div id="loading-screen" style="display:none;">
    <div class="menu-box">
        <h1>Creating World</h1>
        <p id="loading-text">Preparing terrain...</p>

        <div class="loading-bar">
            <div class="loading-fill" id="loading-fill"></div>
        </div>

        <p id="loading-percent">0%</p>
    </div>
    </div>

    <div id="game-ui" class="hidden-ui">
    <div id="crosshair">+</div>
    <div id="info"></div>
    <div id="fps"></div>
    <div id="hud"></div>

    
    <div id="inventory">
        <h2 style="color:white; margin-bottom: 20px; text-align: center;">Inventory</h2>
        <div class="inv-grid" id="invGrid"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <div id="mobile-ui">
    <div id="joystick">
        <div id="stick"></div>
    </div>

<button id="jumpBtn" class="mobile-btn">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 19V5M5 12l7-7 7 7"/>
    </svg>
</button>


    <script>
        let gameStarted = false;
let VIEW_DISTANCE = 30;
let currentWorldId = null;
let lastCellX = Infinity;
let lastCellZ = Infinity;
const IS_MOBILE = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const Noise = (function() { let p = new Uint8Array(512); let permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]; for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); } function lerp(t, a, b) { return a + t * (b - a); } function grad(hash, x, y, z) { let h = hash & 15; let u = h<8 ? x : y, v = h<4 ? y : h==12||h==14 ? x : z; return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v); } return { perlin: function (x, y, z) { let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255; x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z); let u = fade(x), v = fade(y), w = fade(z); let A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z; return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x-1, y, z)), lerp(u, grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z))), lerp(v, lerp(u, grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1)), lerp(u, grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1)))); } }; })();
let fpsFrames = 0;
let fpsLastTime = performance.now();
let fpsValue = 0;

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true});
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Makes shadows look smoother
const sun = new THREE.DirectionalLight(0xffffff, 1.0); // Slightly brighter for contrast
sun.position.set(50, 80, 50);
sun.castShadow = true;

// Configure Shadow Properties
sun.shadow.mapSize.width = 1024; 
sun.shadow.mapSize.height = 1024;
sun.shadow.bias = -0.0005; // Removes "shadow acne" (weird stripes)

// Set the shadow camera area (must cover View Distance)
const d = 50; 
sun.shadow.camera.left = -d;
sun.shadow.camera.right = d;
sun.shadow.camera.top = d;
sun.shadow.camera.bottom = -d;
sun.shadow.camera.near = 0.1;
sun.shadow.camera.far = 200;

scene.add(sun);
scene.add(sun.target); // Important for moving the light later
        document.body.appendChild(renderer.domElement);
        const canvas = renderer.domElement;
        // World Management System
// World Management System
// World Management System
const WorldManager = {
    // Check if we're in Claude.ai or local environment
    isClaudeEnv: typeof window.storage !== 'undefined',

    async saveWorld(worldId, worldConfig) {
        try {
            const saveData = {
                id: worldId,
                name: worldConfig.name,
                seed: worldConfig.seed,
                size: worldConfig.size,
                type: worldConfig.type,
                floatingIslands: worldConfig.floatingIslands,
                shadows: worldConfig.shadows,
                playerPos: {
                    x: player.x,
                    y: player.y,
                    z: player.z
                },
                blocks: worldConfig.blocks || {},  // Use blocks from config
                lastPlayed: Date.now()
            };

            const jsonData = JSON.stringify(saveData);

            if (this.isClaudeEnv) {
                await window.storage.set(`world_${worldId}`, jsonData);
            } else {
                // Fallback to localStorage
                localStorage.setItem(`world_${worldId}`, jsonData);
            }
            
            console.log(`World "${worldConfig.name}" saved successfully!`);
            return true;
        } catch (e) {
            console.error('Failed to save world:', e);
            return false;
        }
    },

    async loadWorld(worldId) {
        try {
            let data;
            if (this.isClaudeEnv) {
                const result = await window.storage.get(`world_${worldId}`);
                if (!result) return null;
                data = result.value;
            } else {
                // Fallback to localStorage
                data = localStorage.getItem(`world_${worldId}`);
                if (!data) return null;
            }
            
            const worldData = JSON.parse(data);
            console.log(`World "${worldData.name}" loaded successfully!`);
            return worldData;
        } catch (e) {
            console.error('Failed to load world:', e);
            return null;
        }
    },

    async listWorlds() {
        try {
            const worlds = [];
            
            if (this.isClaudeEnv) {
                const result = await window.storage.list('world_');
                if (!result || !result.keys) return [];
                
                for (const key of result.keys) {
                    try {
                        const data = await window.storage.get(key);
                        if (data) {
                            const world = JSON.parse(data.value);
                            worlds.push(world);
                        }
                    } catch (e) {
                        console.error('Failed to parse world:', e);
                    }
                }
            } else {
                // Fallback to localStorage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('world_')) {
                        try {
                            const data = localStorage.getItem(key);
                            if (data) {
                                const world = JSON.parse(data);
                                worlds.push(world);
                            }
                        } catch (e) {
                            console.error('Failed to parse world:', e);
                        }
                    }
                }
            }
            
            return worlds.sort((a, b) => b.lastPlayed - a.lastPlayed);
        } catch (e) {
            console.error('Failed to list worlds:', e);
            return [];
        }
    },

    async deleteWorld(worldId) {
        try {
            if (this.isClaudeEnv) {
                await window.storage.delete(`world_${worldId}`);
            } else {
                // Fallback to localStorage
                localStorage.removeItem(`world_${worldId}`);
            }
            return true;
        } catch (e) {
            console.error('Failed to delete world:', e);
            return false;
        }
    }
};

function fakeLoading(onDone) {
    let progress = 0;
    const fill = document.getElementById('loading-fill');
    const percent = document.getElementById('loading-percent');
    const text = document.getElementById('loading-text');

    const steps = [
        "Preparing terrain...",
        "Generating chunks...",
        "Placing blocks...",
        "Growing trees...",
        "Finalizing world..."
    ];

    const interval = setInterval(() => {
        // Increase progress faster
        progress += Math.random() * 20 + 10; // bigger jump
        progress = Math.min(progress, 100);

        fill.style.width = progress + '%';
        percent.textContent = Math.floor(progress) + '%';
        text.textContent = steps[Math.min(
            steps.length - 1,
            Math.floor(progress / 20)
        )];

        if (progress >= 100) {
            clearInterval(interval);
            setTimeout(onDone, 200); // shorter final delay
        }
    }, 80); // shorter interval
}


// --- HAND GROUP ---
const handGroup = new THREE.Group();
camera.add(handGroup);
scene.add(camera);

// Hand mesh
const handGeo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
const handMat = new THREE.MeshLambertMaterial({ color: 0xE0C097 });
const handMesh = new THREE.Mesh(handGeo, handMat);
handMesh.position.set(0.35, -0.45, -0.6);
handMesh.rotation.set(
    THREE.MathUtils.degToRad(80),
    0,
    0
);
handGroup.add(handMesh);

const handBasePos = handMesh.position.clone();
const handBaseRot = handMesh.rotation.clone();

// Block holder
let heldBlockMesh = null;
// Highlight mesh
let highlightMesh = new THREE.Mesh(
    new THREE.BoxGeometry(1.0005, 1.0005, 1.0005), // slightly bigger to avoid z-fighting
    new THREE.MeshBasicMaterial({
        color: 0xffffff,    // white
        transparent: true,
        opacity: 0.2,       // semi-glow
    })
);
highlightMesh.visible = false;
scene.add(highlightMesh);

// Optional: add subtle bloom effect later if you want extra glow


function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
}

window.addEventListener('resize', resize);
resize();

handGroup.add(handMesh);

        // --- UI RENDERER (Cached) ---
const uiRenderer = new THREE.WebGLRenderer({ alpha: true });
uiRenderer.setSize(64,64);
const uiScene = new THREE.Scene();
const uiCam = new THREE.PerspectiveCamera(45, 1, 0.1, 10);
uiCam.position.set(1.5, 1.5, 1.5);
uiCam.lookAt(0.5, 0.5, 0.5);

// 1. Lower the ambient light intensity (prevents the "White Block" look)
uiScene.add(new THREE.AmbientLight(0xffffff, 0.7));

// 2. Add a directional light to the UI scene so the icons have shadows/depth
const uiLight = new THREE.DirectionalLight(0xffffff, 0.8);
uiLight.position.set(1, 2, 1);
uiScene.add(uiLight);

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0xC2C2C2, 0.55);
        scene.add(ambient);
        
        // --- MATERIALS ---
        const loader = new THREE.TextureLoader();
function createMat(url, color = 0xC2C2C2, alphaTest = 0) {
    const t = loader.load(url, tex => {
        tex.magFilter = THREE.NearestFilter;
        tex.minFilter = THREE.NearestFilter;
    });

    return new THREE.MeshLambertMaterial({
        map: t,
        color: color,
        alphaTest: alphaTest,
        side: THREE.DoubleSide,
        vertexColors: true
    });
}


const materials = {
    grassTop: new THREE.MeshLambertMaterial({ color: 0x68BD59 }),
    grassSide: new THREE.MeshLambertMaterial(),
    dirt: new THREE.MeshLambertMaterial(),
    stone: new THREE.MeshLambertMaterial(),
    woodSide: new THREE.MeshLambertMaterial(),
    woodTop: new THREE.MeshLambertMaterial(),
    leaves: new THREE.MeshLambertMaterial({ transparent: true, opacity: 0.9 }),
    bedrock: new THREE.MeshLambertMaterial(),
    cobblestone: new THREE.MeshLambertMaterial(),
    planks: new THREE.MeshLambertMaterial()
};
const blockMaterialMap = {
    grass: [
        materials.grassSide, materials.grassSide,
        materials.grassTop,  materials.dirt,
        materials.grassSide, materials.grassSide
    ],
    wood: [
        materials.woodSide, materials.woodSide,
        materials.woodTop,  materials.woodTop,
        materials.woodSide, materials.woodSide
    ],
    stone: materials.stone,
    dirt: materials.dirt,
    leaves: materials.leaves,
    bedrock: materials.bedrock,
    cobblestone: materials.cobblestone,
    planks: materials.planks
};

        const loadedTextures = {};
function loadTexture(url) {
    return new Promise(resolve => {
        const tex = new THREE.TextureLoader().load(url, t => {
            t.magFilter = THREE.NearestFilter;
            t.minFilter = THREE.NearestFilter;
            resolve(t);
        });
    });
}

async function preloadMaterials() {
    const loader = new THREE.TextureLoader();
    const promises = [];
    for (let key in materials) {
        promises.push(new Promise(resolve => {
            loader.load(`textures/${key.replace(/([A-Z])/g, '_$1').toLowerCase()}.png`, tex => {
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                materials[key].map = tex;
                resolve();
            });
        }));
    }
    await Promise.all(promises);
}

const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        blockGeo.translate(0.5, 0.5, 0.5); 
        // Create a separate geometry for held items (centered at origin)
const heldBlockGeo = new THREE.BoxGeometry(1, 1, 1);
function createBlockMesh(type, x, y, z) {
    // choose material OR per-face array (use blockMaterialMap first)
    let mat = blockMaterialMap[type] || materials[type] || materials.stone;

    const mesh = new THREE.Mesh(blockGeo, mat);

    // set correct world position! (this was missing)
    mesh.position.set(x, y, z);

    // shadow choices — avoid huge shadow cost for low-value blocks
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    mesh.userData = { type, x, y, z };
    return mesh;
}

        

        // --- WORLD DATA (Separated from Visuals) ---
        const worldData = {}; // key: "x,y,z" -> val: type
        const surfaceHeight = {};

        // --- NEW INSTANCING SYSTEM ---
const MAX_INSTANCES = 10000; // Max blocks of ONE type visible at once
const instancedMeshes = {}; // Stores the "Managers"
const dummy = new THREE.Object3D(); // Helper to calculate positions

function initInstancedMeshes() {
    for (const key in instancedMeshes) {
        scene.remove(instancedMeshes[key]);
    }

    // Define all block types you want to support
    const types = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'cobblestone', 'planks', 'bedrock'];

    types.forEach(type => {
        let mat = blockMaterialMap[type] || materials[type] || materials.stone;
        
        // We MUST use the same geometry for every manager
        const mesh = new THREE.InstancedMesh(blockGeo, mat, MAX_INSTANCES);
        
        mesh.castShadow = (type !== 'leaves');
        mesh.receiveShadow = true;
        mesh.count = 0; 

        scene.add(mesh);
        instancedMeshes[type] = mesh;
    });
}


// --- SOUNDS ---
const sounds = {
    walk: [
        new Audio('sounds/Walk1.ogg'),
        new Audio('sounds/Walk2.ogg'),
        new Audio('sounds/Walk3.ogg'),
        new Audio('sounds/Walk4.ogg')
    ],
    break: new Audio('sounds/break.ogg'),
    place: new Audio('sounds/place.ogg')
};

// Ensure audio objects are ready and use them without cloning to avoid play delays
Object.values(sounds).flat().forEach(a => {
    a.preload = 'auto';
    a.volume = 0.4;
    // don't call play here; we'll reset currentTime and play when needed
});

function playWalkSound() {
    // reuse existing audio objects to reduce creation overhead
    const list = sounds.walk;
    const s = list[Math.floor(Math.random() * list.length)];
    try {
        s.currentTime = 0;
        s.play();
    } catch (err) {
        // some browsers require user interaction before sound; ignore errors
    }
}

function playSound(name) {
    if (!sounds[name]) return;
    const a = sounds[name];
    try {
        a.currentTime = 0;
        a.play();
    } catch (err) {
        // ignore
    }
}


        function setBlockData(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (type === null) {
                delete worldData[key];
            } else {
                worldData[key] = type;
            }
        }

        function getBlockType(x, y, z) {
            return worldData[`${x},${y},${z}`];
        }

        // --- OPTIMIZED RENDERING (OCCLUSION CULLING) ---
        function isBlockObscured(x, y, z) {
            // Check all 6 neighbors. If all 6 are solid, this block is hidden.
            if (!getBlockType(x+1, y, z)) return false;
            if (!getBlockType(x-1, y, z)) return false;
            if (!getBlockType(x, y+1, z)) return false;
            if (!getBlockType(x, y-1, z)) return false;
            if (!getBlockType(x, y, z+1)) return false;
            if (!getBlockType(x, y, z-1)) return false;
            return true;
        }
renderer.domElement.style.touchAction = 'none';

function updateHeldItem() {
    handMesh.visible = true;

    if (heldBlockMesh) {
        handMesh.remove(heldBlockMesh);
        heldBlockMesh = null;
    }

    const blockType = hotbar[selectedSlot];
if (blockType) {
    let mat = blockMaterialMap[blockType] || materials[blockType] || materials.stone;
    
    heldBlockMesh = new THREE.Mesh(heldBlockGeo, mat);
    heldBlockMesh.scale.set(0.4, 0.4, 0.4);
    handMesh.add(heldBlockMesh);
    heldBlockMesh.position.set(0, -0.3, -0.2);
    heldBlockMesh.rotation.set(
        -Math.PI / 2.5,  // Counter-rotate to make top face up
        0,               // NO 45° rotation
        0
    );
}
}
function renderWorld() {
    // 1. Reset counts
    for (const key in instancedMeshes) {
        instancedMeshes[key].count = 0;
    }

    const px = Math.round(player.x);
    const pz = Math.round(player.z);
    const d = VIEW_DISTANCE;

    // 2. Optimized Triple Loop
    for (let x = px - d; x <= px + d; x++) {
        for (let z = pz - d; z <= pz + d; z++) {
            
            // Check distance once per column (faster)
            const dx = x - player.x;
            const dz = z - player.z;
            if (dx * dx + dz * dz > d * d) continue;

            for (let y = 0; y < 60; y++) {
                const type = getBlockType(x, y, z);
                if (!type) continue;

                // Simple Occlusion Culling
                if (isBlockObscured(x, y, z)) continue;

                const mesh = instancedMeshes[type];
                
                // Safety: Check if mesh exists and we haven't hit the limit
                if (mesh && mesh.count < MAX_INSTANCES) {
                    dummy.position.set(x, y, z);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(mesh.count, dummy.matrix);
                    mesh.count++;
                }
            }
        }
    }

    // 3. Update GPU (The most important part!)
    for (const key in instancedMeshes) {
        instancedMeshes[key].instanceMatrix.needsUpdate = true;
    }
}
function findSpawnPosition() {
    let bestDistSq = Infinity;
    let spawnX = 0;
    let spawnY = 0;
    let spawnZ = 0;

    for (let x = -8; x <= 8; x++) {
        for (let z = -8; z <= 8; z++) {

            const distSq = x * x + z * z;
            if (distSq >= bestDistSq) continue;

            for (let y = 100; y >= 0; y--) {
                if (getBlockType(x, y, z) !== 'grass') continue;

                const above1 = getBlockType(x, y + 1, z);
                const above2 = getBlockType(x, y + 2, z);

                // Air = no block returned
                if (above1 || above2) continue;

                bestDistSq = distSq;
                spawnX = x + 0.5;
                spawnY = y;
                spawnZ = z + 0.5;
                break;
            }
        }
    }

    if (bestDistSq === Infinity) {
        return { x: 0.5, y: 5, z: 0.5 };
    }

    return {
        x: spawnX,
        y: spawnY , // feet on grass
        z: spawnZ
    };
}

function generateWorld(worldConfig) {
const worldSize = worldConfig.size;
    const floatingIslands = worldConfig.floatingIslands;
    const worldType = worldConfig.type;
    const seedInput = worldConfig.seed;

            if (IS_MOBILE) {
    document.getElementById('mobile-ui').style.display = 'block';

    // enable buttons only
    document.querySelectorAll('.mobile-btn, #joystick')
        .forEach(el => el.style.pointerEvents = 'auto');
}
const input = seedInput;
// Simple hash for seed
const seed = input ? parseInt(input.split('').reduce((a,b)=>a+b.charCodeAt(0),0)) : Math.floor(Math.random()*10000);

const size = worldSize;  // ✅ Add this line
            for(let x = -size; x <= size; x++) {
                for(let z = -size; z <= size; z++) {
                    // Use Perlin Noise for smooth terrain
                    let h;

// ───────── FLAT WORLD ─────────
if (worldType === 'flat') {
    h = 4; // flat grass level
}

// ───────── NORMAL WORLD ─────────
else {
    let noiseVal = Noise.perlin(x * 0.1 + seed, 0, z * 0.1 + seed);

    if (floatingIslands) {
        const islandNoise = Noise.perlin(x * 0.08 + seed, 50, z * 0.08 + seed);
        if (islandNoise > 0.15) {
            h = Math.floor(20 + islandNoise * 15);
        } else {
            continue; // air
        }
    } else {
        h = Math.floor(5 + Math.abs(noiseVal) * 10);
    }
}


                    
                    setBlockData(x, 0, z, 'bedrock');
                    for(let y = 1; y < h-2; y++) setBlockData(x, y, z, 'stone');
                    setBlockData(x, h-2, z, 'dirt');
                    setBlockData(x, h-1, z, 'dirt');
                    setBlockData(x, h, z, 'grass');
surfaceHeight[`${x},${z}`] = h;

                }
            }
// ───────── TREE GENERATION (SECOND PASS) ─────────

// deterministic random
function rand2D(x, z, seed) {
    const n = Math.sin(
        x * 127.1 +
        z * 311.7 +
        seed * 74.7
    ) * 43758.5453123;
    return n - Math.floor(n);
}

for (let x = -size; x <= size; x++) {
    for (let z = -size; z <= size; z++) {

        const h = surfaceHeight[`${x},${z}`];
        if (h === undefined) continue;
        if (getBlockType(x, h, z) !== 'grass') continue;

        // VERY RARE chance (controls density)
        if (rand2D(x, z, seed) < 0.99) continue;

        // spacing: no trees within 4 blocks
        let blocked = false;
        for (let dx = -2; dx <= 2 && !blocked; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
                if (getBlockType(x + dx, h + 1, z + dz) === 'wood') {
                    blocked = true;
                    break;
                }
            }
        }
        if (blocked) continue;

        const trunkHeight =
            4 + Math.floor(rand2D(x + 5, z + 9, seed) * 2);

        // trunk (wood)
        for (let t = 1; t <= trunkHeight; t++) {
            setBlockData(x, h + t, z, 'wood');
        }

        // leaves (Minecraft style)
        const topY = h + trunkHeight;

        // Layer 1 (top)
        setBlockData(x, topY + 2, z, 'leaves');

        // Layer 2 (middle) – center stays as trunk
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                if (dx !== 0 || dz !== 0) { // center is trunk
                    setBlockData(x + dx, topY + 1, z + dz, 'leaves');
                }
            }
        }

        // Layer 3 (bottom) – center stays as trunk
        for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
                if (Math.abs(dx) + Math.abs(dz) <= 2 && (dx !== 0 || dz !== 0)) {
                    setBlockData(x + dx, topY, z + dz, 'leaves');
                }
            }
        }
    }
}


            // Inside startGame, after generating terrain:
const spawn = findSpawnPosition();
player.x = spawn.x;
player.z = spawn.z;
player.y = spawn.y + 5; // Spawn 5 blocks ABOVE the ground
player.vy = 0;
renderWorld(); // Initial render

            // Force hotbar refresh after world is ready
setTimeout(() => {
    updateHotbar();
    updateInfo();
    updateHeldItem();
}, 100);

        }

        // --- PLAYER ---
        const player = {
    x: 0.5,
    y: 30,
    z: 0.5,
    vy: 0,
    yaw: 0,
    pitch: 0,
    onGround: false,
};

        const keys = {};
        const PLAYER_HEIGHT = 1.6;
        const PLAYER_RADIUS = 0.25;

        // Inventory
        let selectedSlot = 0;
        let inventoryOpen = false;
        let mouseLocked = false;
        const hotbar = ['grass', 'stone', 'wood', 'leaves', 'dirt', 'cobblestone', 'planks', 'bedrock', null];
        const allItems = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'cobblestone', 'planks', 'bedrock'];

function checkCollision(x, y, z) {
    const feetY = y - PLAYER_HEIGHT + 0.2; // Lifted slightly to avoid floor-snag
    const headY = y - 0.2;
    
    // Shrink the player radius slightly for smoother movement
    const r = PLAYER_RADIUS * 0.8; 

    const points = [
        {x: x - r, z: z - r},
        {x: x + r, z: z - r},
        {x: x - r, z: z + r},
        {x: x + r, z: z + r}
    ];

    for (let p of points) {
        // Use Math.floor to check the exact block coordinates in worldData
        if (getBlockType(Math.floor(p.x), Math.floor(feetY), Math.floor(p.z))) return true;
        if (getBlockType(Math.floor(p.x), Math.floor(headY), Math.floor(p.z))) return true;
        
        // Add a check for the middle of the body
        const midY = (feetY + headY) / 2;
        if (getBlockType(Math.floor(p.x), Math.floor(midY), Math.floor(p.z))) return true;
    }
    return false;
}

function updatePlayer(dt) {
    const delta = Math.min(dt, 0.05);
    const walkSpeed = 4;
    const gravity = 30;
    const jumpForce = 10;

    let dx = 0, dz = 0;
    let moved = false;

    // --- 1. INPUT DETECTION LOGS ---
    if (keys['w']) { dx -= Math.sin(player.yaw); dz -= Math.cos(player.yaw); moved = true; }
    if (keys['s']) { dx += Math.sin(player.yaw); dz += Math.cos(player.yaw); moved = true; }
    if (keys['a']) { dx -= Math.cos(player.yaw); dz += Math.sin(player.yaw); moved = true; }
    if (keys['d']) { dx += Math.cos(player.yaw); dz -= Math.sin(player.yaw); moved = true; }

    if (moved) console.log("Movement detected: ", {dx, dz});
    if (keys[' ']) console.log("Jump key pressed! Player onGround:", player.onGround);

    // --- 2. MOVEMENT LOGIC ---
    const inputLen = Math.sqrt(dx * dx + dz * dz);
    if (inputLen > 0) {
        dx /= inputLen;
        dz /= inputLen;
    }

    const moveX = dx * walkSpeed * delta;
    const moveZ = dz * walkSpeed * delta;

    // Check X
    if (!checkCollision(player.x + moveX, player.y, player.z)) {
        player.x += moveX;
    } else if (moved) {
        console.warn("X collision blocked movement");
    }

    // Check Z
    if (!checkCollision(player.x, player.y, player.z + moveZ)) {
        player.z += moveZ;
    } else if (moved) {
        console.warn("Z collision blocked movement");
    }

    // --- 3. JUMP & GRAVITY ---
    const onGround = checkCollision(player.x, player.y - 0.1, player.z);
    player.onGround = onGround;

    if (onGround) {
        player.vy = Math.max(player.vy, 0);
        if (keys[' ']) {
            player.vy = jumpForce;
            player.onGround = false;
        }
    } else {
        player.vy -= gravity * delta;
    }

    const moveY = player.vy * delta;
    if (!checkCollision(player.x, player.y + moveY, player.z)) {
        player.y += moveY;
    } else {
        player.vy = 0;
    }

    // --- 4. SYNC ---
    camera.position.set(player.x, player.y, player.z);
    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
}
let swinging = false;
let swingTime = 0;
const SWING_DURATION = 0.35; // Minecraft swings are faster (~0.35s)

function startSwing() {
    if (!swinging) {
        swinging = true;
        swingTime = 0;
    }
}

function updateSwing(dt) {
    if (!swinging) return;
    
    swingTime += dt;
    const t = Math.min(swingTime / SWING_DURATION, 1);
    
    // Ease-out curve for snappy feel
    const ease = 1 - Math.pow(1 - t, 3);
    
    // MINECRAFT PATTERN: Forward+Up → Left+Down → Right
    const phase1 = Math.min(ease * 2, 1);
    const phase2 = Math.max((ease - 0.5) * 2, 0);
    
    const forwardUp = Math.sin(phase1 * Math.PI * 0.5);
    const arc = Math.sin(phase2 * Math.PI);
    
    // Position calculation
    handMesh.position.x = handBasePos.x - 0.5 * arc;
    handMesh.position.y = handBasePos.y + 0.2 * forwardUp - 0.4 * phase2;
    handMesh.position.z = handBasePos.z - 0.3 * forwardUp;
    
// Block follows hand
if (heldBlockMesh) {
    heldBlockMesh.position.set(0, -0.3, -0.2);
    heldBlockMesh.rotation.set(-Math.PI / 2.5, 0, 0);
}
    
// Reset when done
if (t >= 1) {
    swinging = false;
    swingTime = 0;
    handMesh.position.copy(handBasePos);
    if (heldBlockMesh) {
        heldBlockMesh.position.set(0, -0.3, -0.2);
        heldBlockMesh.rotation.set(-Math.PI / 2.5, 0, 0);
    }
}
}
// 3D Panorama System (FNAF-style)
let panoramaScene, panoramaCamera, panoramaRenderer, panoramaSkybox;
let panoramaRotation = 0;
let panoramaMouseX = 0;
let panoramaMouseY = 0;

function initPanorama() {
    const canvas = document.getElementById('panorama-canvas');
    if (!canvas) return;

    // Setup scene
    panoramaScene = new THREE.Scene();
    
    // Camera with perspective
    panoramaCamera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
    );
    panoramaCamera.position.set(0, 0, 0);
    
    // Renderer
    panoramaRenderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true 
    });
    panoramaRenderer.setSize(window.innerWidth, window.innerHeight);
    
    // Create skybox sphere (inside-out)
    const skyboxGeo = new THREE.SphereGeometry(50, 32, 32);
    
    // Load panorama texture
    const textureLoader = new THREE.TextureLoader();
    const panoramaTexture = textureLoader.load('guistuff/panorama.png', () => {
        // Texture loaded successfully
        console.log('Panorama loaded');
    }, undefined, () => {
        // Fallback: create procedural skybox if image fails
        console.warn('Panorama image not found, using procedural sky');
        createProceduralSkybox();
    });
    
    const skyboxMat = new THREE.MeshBasicMaterial({
        map: panoramaTexture,
        side: THREE.BackSide // Render inside of sphere
    });
    
    panoramaSkybox = new THREE.Mesh(skyboxGeo, skyboxMat);
    panoramaScene.add(panoramaSkybox);
    
    // Mouse tracking for perspective
    document.addEventListener('mousemove', (e) => {
        if (document.getElementById('main-menu').style.display !== 'none') {
            panoramaMouseX = (e.clientX / window.innerWidth) * 2 - 1;
            panoramaMouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (panoramaCamera && panoramaRenderer) {
            panoramaCamera.aspect = window.innerWidth / window.innerHeight;
            panoramaCamera.updateProjectionMatrix();
            panoramaRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    
    // Start animation
    animatePanorama();
}

function createProceduralSkybox() {
    // Fallback: Create a simple gradient skybox
    const canvas = document.createElement('canvas');
    canvas.width = 2048;
    canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    
    // Sky gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(1, '#E0F6FF');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 2048, 1024);
    
    // Add some clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    for (let i = 0; i < 20; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 512;
        const w = 100 + Math.random() * 200;
        const h = 40 + Math.random() * 60;
        ctx.fillRect(x, y, w, h);
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    panoramaSkybox.material.map = texture;
    panoramaSkybox.material.needsUpdate = true;
}

function animatePanorama() {
    if (!panoramaRenderer || !panoramaScene || !panoramaCamera) return;
    
    // Only animate if main menu is visible
    if (document.getElementById('main-menu').style.display !== 'none') {
        requestAnimationFrame(animatePanorama);
        
        // Slow auto-rotation
        panoramaRotation -= 0.0008;
        
        // Mouse-based perspective (FNAF-style)
        const targetRotationY = panoramaRotation;
        const targetRotationX = panoramaCamera.rotation.x;
        
        // Smooth camera movement
        panoramaCamera.rotation.y += (targetRotationY - panoramaCamera.rotation.y);
        panoramaCamera.rotation.x += (targetRotationX - panoramaCamera.rotation.x);
        
        // Render
        panoramaRenderer.render(panoramaScene, panoramaCamera);
    }
}


// Initialize on page load
window.addEventListener('load', () => {
    initPanorama();
});

// Update showMainMenu to start panorama
function showMainMenu() {
    document.getElementById('main-menu').style.display = 'block';
    document.getElementById('world-select').style.display = 'none';
    document.getElementById('create-world').style.display = 'none';
    document.getElementById('settings-menu').style.display = 'none';
    
    // Start panorama animation
    if (panoramaRenderer) {
        animatePanorama();
    }
}
async function showWorldSelect() {
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('world-select').style.display = 'flex';
    
    const worldList = document.getElementById('world-list');
    worldList.innerHTML = '<p style="color:#888;">Loading worlds...</p>';
    
    const worlds = await WorldManager.listWorlds();
    
    if (worlds.length === 0) {
        worldList.innerHTML = '<p style="color:#888;">No worlds found. Create one!</p>';
        return;
    }
    
    worldList.innerHTML = '';
    worlds.forEach(world => {
        const card = document.createElement('div');
        card.className = 'world-card';
        card.innerHTML = `
            <button class="delete-btn" onclick="deleteWorldConfirm('${world.id}', event)">Delete</button>
            <h3>${world.name}</h3>
            <p>Seed: ${world.seed || 'Random'}</p>
            <p>Size: ${world.size === 30 ? 'Small' : world.size === 99 ? 'Medium' : 'Large'}</p>
            <p>Last played: ${new Date(world.lastPlayed).toLocaleDateString()}</p>
        `;
        card.onclick = (e) => {
            if (!e.target.classList.contains('delete-btn')) {
                loadAndStartWorld(world.id);
            }
        };
        worldList.appendChild(card);
    });
}

function showCreateWorld() {
    document.getElementById('world-select').style.display = 'none';
    document.getElementById('create-world').style.display = 'flex';
}

function showSettings() {
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('settings-menu').style.display = 'flex';
}

function saveSettings() {
    const settings = {
        renderDistance: document.getElementById('renderDistance').value,
        showFPS: document.getElementById('settingsFPS').checked,
        shadows: document.getElementById('settingsShadows').checked,
        leavesAlpha: document.getElementById('settingsLeavesAlpha').checked
    };
    // Leaves Transparency Logic
    const leavesAlpha = document.getElementById('settingsLeavesAlpha').checked;
    if (materials.leaves) {
        materials.leaves.transparent = leavesAlpha;
        materials.leaves.opacity = leavesAlpha ? 0.8 : 1.0;
        materials.leaves.needsUpdate = true;
    }
    // Save to localStorage
    localStorage.setItem('blockworld_settings', JSON.stringify(settings));
    
    // Apply live
    VIEW_DISTANCE = parseInt(settings.renderDistance);
    document.getElementById('fps').style.display = settings.showFPS ? 'block' : 'none';
    
    showMainMenu();
}

// Add this to your window 'load' event to restore settings on startup
window.addEventListener('load', () => {
    const saved = localStorage.getItem('blockworld_settings');
    if (saved) {
        const s = JSON.parse(saved);
        VIEW_DISTANCE = parseInt(s.renderDistance);
        document.getElementById('renderDistance').value = s.renderDistance;
        document.getElementById('settingsFPS').checked = s.showFPS;
        document.getElementById('settingsShadows').checked = s.shadows;
        document.getElementById('fps').style.display = s.showFPS ? 'block' : 'none';
        document.getElementById('settingsLeavesAlpha').checked = s.leavesAlpha;

        if (materials.leaves) {
            materials.leaves.transparent = s.leavesAlpha;
            materials.leaves.opacity = s.leavesAlpha ? 0.8 : 1.0;
        }
    }
    initPanorama();
});

async function deleteWorldConfirm(worldId, event) {
    event.stopPropagation();
    if (confirm('Are you sure you want to delete this world? This cannot be undone!')) {
        await WorldManager.deleteWorld(worldId);
        showWorldSelect();
    }
}

async function createNewWorld() {
    const worldName = document.getElementById('worldName').value || 'New World';
    const worldId = 'world_' + Date.now();
    
    currentWorldId = worldId;
    
    const worldConfig = {
        id: worldId,
        name: worldName,
        seed: document.getElementById('seed').value,
        size: parseInt(document.getElementById('worldSize').value),
        type: document.getElementById('worldType').value,
        floatingIslands: document.getElementById('floatingIslands').checked,
        shadows: document.getElementById('settingsShadows').checked  // ← Use settings value
    };
    
    startGame(worldConfig);
}

async function loadAndStartWorld(worldId) {
    const worldData = await WorldManager.loadWorld(worldId);
    if (!worldData) {
        alert('Failed to load world!');
        return;
    }
    
    currentWorldId = worldId;
    startGame(worldData, true);
}
async function startGame(worldConfig, isLoadingWorld = false) {
    // ADD THIS LINE at the very top of the function
    currentWorldConfig = worldConfig;
    // Hide all menus
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('world-select').style.display = 'none';
    document.getElementById('create-world').style.display = 'none';
    document.getElementById('settings-menu').style.display = 'none';

    // Hide game UI
    document.getElementById('game-ui').classList.add('hidden-ui');

    // Show loading screen
    const loading = document.getElementById('loading-screen');
    loading.style.display = 'flex';

    // Apply world settings
    const useShadows = worldConfig.shadows;
    renderer.shadowMap.enabled = useShadows;
    renderer.shadowMap.autoUpdate = useShadows;
    sun.castShadow = useShadows;
const leavesAlpha = document.getElementById('settingsLeavesAlpha').checked;
    materials.leaves.transparent = leavesAlpha;
    materials.leaves.opacity = leavesAlpha ? 0.8 : 1.0;

    await preloadMaterials();
    initInstancedMeshes();

    // Start fake loading FIRST
    fakeLoading(() => {
        // When fake loading completes
        gameStarted = true;
        loading.style.display = 'none';

        // Show UI
        document.getElementById('game-ui').classList.remove('hidden-ui');

        // Enable mobile UI if needed
        if (IS_MOBILE) {
            document.getElementById('mobile-ui').style.display = 'block';
            document.querySelectorAll('.mobile-btn, #joystick')
                .forEach(el => el.style.pointerEvents = 'auto');
        }

        lastTime = performance.now();
        animate();
    });

    // Generate world AFTER browser has time to paint loading screen
    setTimeout(() => {
        if (isLoadingWorld) {
            // Load existing world data
            for (const key in worldConfig.blocks) {
                worldData[key] = worldConfig.blocks[key];
            }

            // Restore player position
            if (worldConfig.playerPos) {
                player.x = worldConfig.playerPos.x;
                player.y = worldConfig.playerPos.y;
                player.z = worldConfig.playerPos.z;
            }

            renderWorld();
        } else {
            // Generate new world
            generateWorld(worldConfig);
        }

        // Force hotbar refresh after world is ready
        setTimeout(() => {
            updateHotbar();
            updateInfo();
            updateHeldItem();
        }, 100);
    }, 50);
}

let lastChunkX = 9999;
let lastChunkZ = 9999;
function maybeUpdateWorld() {
    // Round player position to nearest 4th block to reduce update frequency
    const curX = Math.floor(player.x / 4);
    const curZ = Math.floor(player.z / 4);

    if (curX !== lastCellX || curZ !== lastCellZ) {
        lastCellX = curX;
        lastCellZ = curZ;
        renderWorld();
    }
}

        // --- UI SYSTEM ---
        const iconCache = {};
function getIcon(type) {
    if (!type) return '';
    if (iconCache[type]) return iconCache[type];

    const mat = blockMaterialMap[type] || materials.stone;
    
    // Check if textures are loaded - if not, return placeholder
    if (Array.isArray(mat)) {
        // Multi-material array (like grass)
        if (!mat[0].map || !mat[0].map.image) return '';
    } else {
        // Single material
        if (!mat.map || !mat.map.image) return '';
    }

    const mesh = new THREE.Mesh(blockGeo, mat);
    mesh.scale.set(0.65, 0.65, 0.65);
    mesh.position.set(0.175, 0.175, 0.175);

    uiScene.add(mesh);
    uiRenderer.render(uiScene, uiCam);

    const url = uiRenderer.domElement.toDataURL();
    uiScene.remove(mesh);

    iconCache[type] = url;
    return url;
}

function toggleInventory() {
    inventoryOpen = !inventoryOpen;
    document.getElementById('inventory').classList.toggle('visible');

    if (inventoryOpen) {
        updateInventory();
    }
}

        function updateHotbar() {
    const h = document.getElementById('hud');

    // Create once
    if (!h.hasChildNodes()) {
        hotbar.forEach((t, i) => {
            const s = document.createElement('div');
            s.className = 'slot';
            s.dataset.slot = i;

            if (t) {
                s.innerHTML = `<img src="${getIcon(t)}"><span class="slot-count">∞</span>`;
            }

            if (IS_MOBILE) {
                s.addEventListener('touchstart', e => {
                    e.preventDefault();
                    selectedSlot = i;
                    updateHotbar();
                    updateHeldItem();
                });
            }

            h.appendChild(s);
        });
    }

    // Update selection + content
    [...h.children].forEach((s, i) => {
        s.classList.toggle('selected', i === selectedSlot);

        const t = hotbar[i];
        s.innerHTML = t
            ? `<img src="${getIcon(t)}"><span class="slot-count">∞</span>`
            : '';
    });
}


        function updateInventory() {
            const g = document.getElementById('invGrid'); g.innerHTML = '';
            allItems.forEach(t => {
                const s = document.createElement('div'); s.className = 'slot';
                s.innerHTML = `<img src="${getIcon(t)}"><span>${t.toUpperCase()}</span>`;
                s.onclick = () => {
    hotbar[selectedSlot] = t;
    updateHotbar();
    updateHeldItem();
};

                g.appendChild(s);
            });
        }

        function updateInfo() {
    document.getElementById('info').innerHTML = 
        `BlockWorld v0.4<br>
        R/Reload Page = Quit World<br>
        XYZ: ${player.x.toFixed(1)} / ${player.y.toFixed(1)} / ${player.z.toFixed(1)}`;
}


        // --- EVENTS ---
        const raycaster = new THREE.Raycaster();
        function blockIntersectsPlayer(bx, by, bz) {
    const playerMinX = player.x - PLAYER_RADIUS;
    const playerMaxX = player.x + PLAYER_RADIUS;
    const playerMinY = player.y - PLAYER_HEIGHT;
    const playerMaxY = player.y;
    const playerMinZ = player.z - PLAYER_RADIUS;
    const playerMaxZ = player.z + PLAYER_RADIUS;

    const blockMinX = bx;
    const blockMaxX = bx + 1;
    const blockMinY = by;
    const blockMaxY = by + 1;
    const blockMinZ = bz;
    const blockMaxZ = bz + 1;

    return (
        playerMinX < blockMaxX &&
        playerMaxX > blockMinX &&
        playerMinY < blockMaxY &&
        playerMaxY > blockMinY &&
        playerMinZ < blockMaxZ &&
        playerMaxZ > blockMinZ
    );
}
function shouldRenderBlock(x, y, z) {
    const dx = x - player.x;
    const dy = y - player.y;
    const dz = z - player.z;
    return dx*dx + dy*dy + dz*dz <= VIEW_DISTANCE * VIEW_DISTANCE;
}



        function getRaycastTarget() {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    raycaster.set(camera.position, dir);

    // We now check against the InstancedMeshes, not individual blocks
    const meshesToCheck = Object.values(instancedMeshes);
    const hits = raycaster.intersectObjects(meshesToCheck);

    if (hits.length > 0 && hits[0].distance < 6) {
        const hit = hits[0];
        
        // --- KEY CHANGE: Calculate position from Matrix ---
        const matrix = new THREE.Matrix4();
        hit.object.getMatrixAt(hit.instanceId, matrix);
        
        const position = new THREE.Vector3();
        position.setFromMatrixPosition(matrix);
        
        // Round to nearest whole number to get grid coordinates
        return {
            x: Math.round(position.x),
            y: Math.round(position.y),
            z: Math.round(position.z),
            face: hit.face,
            distance: hit.distance
        };
    }
    return null;
}

// Update your mouse listener to use this:
document.addEventListener('mousedown', e => {
    if (!mouseLocked || inventoryOpen) return;
    startSwing();

    const target = getRaycastTarget();
    
    if (target) {
        const {x, y, z, face} = target;

        if (e.button === 0) { // Left Click (Break)
            setBlockData(x, y, z, null);
            playSound('break');
            renderWorld(); // Re-build the instances
        } 
        else if (e.button === 2) { // Right Click (Place)
            const nx = x + face.normal.x;
            const ny = y + face.normal.y;
            const nz = z + face.normal.z;
            
            if (!blockIntersectsPlayer(nx, ny, nz) && hotbar[selectedSlot]) {
                setBlockData(nx, ny, nz, hotbar[selectedSlot]);
                playSound('place');
                renderWorld(); // Re-build the instances
            }
        }
    }
});

        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        document.addEventListener('wheel', e => {
            if(inventoryOpen) return;
            if(e.deltaY > 0) selectedSlot = (selectedSlot + 1) % 9;
            else selectedSlot = (selectedSlot - 1 + 9) % 9;
            updateHotbar();
            updateHeldItem();
        });

        document.addEventListener('mousemove', e => {
            if(mouseLocked) {
                player.yaw -= e.movementX * 0.002;
                player.pitch = Math.max(-1.5, Math.min(1.5, player.pitch - e.movementY * 0.002));
            }
        });
        
        document.addEventListener('click', () => {
    if (!gameStarted || IS_MOBILE) return;
    if (!inventoryOpen) renderer.domElement.requestPointerLock();
});
function takePanoramaScreenshot() {
    // Hide UI temporarily
    const gameUI = document.getElementById('game-ui');
    const wasHidden = gameUI.classList.contains('hidden-ui');
    gameUI.classList.add('hidden-ui');
    
    // Wait one frame for UI to hide
    requestAnimationFrame(() => {
        // Render clean frame
        renderer.render(scene, camera);
        
        // Get canvas data
        const link = document.createElement('a');
        link.download = `blockworld_panorama_${Date.now()}.png`;
        link.href = renderer.domElement.toDataURL('image/png');
        link.click();
        
        // Restore UI if it wasn't hidden before
        if (!wasHidden) {
            gameUI.classList.remove('hidden-ui');
        }
        
        console.log('Panorama saved!');
    });
}

document.addEventListener('keydown', async (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }
    
    const k = e.key.toLowerCase();
    keys[k] = true;
    
 // F5 - Take Panorama Screenshot
    if (e.key === 'F5') {
        e.preventDefault();
        takePanoramaScreenshot();
        return;
    }
    
if (k === 'r') {
    e.preventDefault();
    if (gameStarted && currentWorldId && currentWorldConfig) {
        currentWorldConfig.blocks = worldData;
        // We force the code to wait until the save is 100% done before reloading
        WorldManager.saveWorld(currentWorldId, currentWorldConfig).then(() => {
            window.location.reload(); 
        });
    }
}

    if (k >= '1' && k <= '9') {
        selectedSlot = parseInt(k) - 1;
        updateHotbar();
        updateHeldItem();
    }
});

document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});
        document.addEventListener('pointerlockchange', () => mouseLocked = !!document.pointerLockElement);
        window.addEventListener('resize', () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

jumpBtn.addEventListener('touchstart', e => {
    e.preventDefault();

    if (player.flying || player.onGround) {
        player.vy = 10;
        player.onGround = false;
    }
});


renderer.domElement.addEventListener('touchmove', e => {
    e.preventDefault();
}, { passive: false });

    let joyX = 0;
let joyY = 0;
let joyTouchId = null;

const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');

if (joystick && stick) {

    joystick.addEventListener('touchstart', e => {
        e.preventDefault();
        e.stopPropagation();

        if (joyTouchId !== null) return;

        const t = e.changedTouches[0];
        joyTouchId = t.identifier;
    }, { passive: false });

    joystick.addEventListener('touchmove', e => {
        e.preventDefault();
        e.stopPropagation();

        let t = null;
        for (const touch of e.changedTouches) {
            if (touch.identifier === joyTouchId) {
                t = touch;
                break;
            }
        }
        if (!t) return;

        const rect = joystick.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;

        let dx = t.clientX - cx;
        let dy = t.clientY - cy;

        const radius = rect.width / 2;
        const dist = Math.hypot(dx, dy);

        // Smooth circular clamp
        const clampedDist = Math.min(dist, radius);
        const angle = Math.atan2(dy, dx);

        dx = Math.cos(angle) * clampedDist;
        dy = Math.sin(angle) * clampedDist;

        // Normalized joystick values
        joyX = dx / radius;
        joyY = dy / radius;

        // Deadzone (prevents jitter at corners)
        const dead = 0.15;
        if (Math.abs(joyX) < dead) joyX = 0;
        if (Math.abs(joyY) < dead) joyY = 0;

        stick.style.transform =
            `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

        // Clear keys first
        keys['w'] = keys['a'] = keys['s'] = keys['d'] = false;

        // Direction based on angle (NOT square axes)
        if (joyY < 0) keys['w'] = true;
        if (joyY > 0) keys['s'] = true;
        if (joyX < 0) keys['a'] = true;
        if (joyX > 0) keys['d'] = true;

    }, { passive: false });

    joystick.addEventListener('touchend', e => {
        for (const t of e.changedTouches) {
            if (t.identifier === joyTouchId) {
                joyTouchId = null;
                break;
            }
        }

        joyX = joyY = 0;
        stick.style.transform = 'translate(-50%, -50%)';
        keys['w'] = keys['a'] = keys['s'] = keys['d'] = false;
    }, { passive: false });

    joystick.addEventListener('touchcancel', () => {
        joyTouchId = null;
        joyX = joyY = 0;
        stick.style.transform = 'translate(-50%, -50%)';
        keys['w'] = keys['a'] = keys['s'] = keys['d'] = false;
    });
}


/* ---------------------------
   MOBILE: unified multi-touch
   - swipe = look
   - tap = place
   - hold = break
   - touches on UI (joystick/buttons) are ignored here
   - supports multi-touch and simultaneous move/look
   --------------------------- */

if (IS_MOBILE) {
    const activeTouches = {}; 
    const HOLD_MS = 220;

    function getMobileTarget() {
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        raycaster.set(camera.position, dir);

        // Check against all instanced managers
        const meshesToCheck = Object.values(instancedMeshes);
        const hits = raycaster.intersectObjects(meshesToCheck);

        if (hits.length > 0 && hits[0].distance < 6) {
            const hit = hits[0];
            const matrix = new THREE.Matrix4();
            
            // Get the specific block's matrix
            hit.object.getMatrixAt(hit.instanceId, matrix);
            
            const position = new THREE.Vector3();
            position.setFromMatrixPosition(matrix);
            
            return {
                x: Math.round(position.x),
                y: Math.round(position.y),
                z: Math.round(position.z),
                face: hit.face
            };
        }
        return null;
    }

    function breakBlock() {
        const target = getMobileTarget();
        if (target) {
            startSwing();
            setBlockData(target.x, target.y, target.z, null);
            playSound('break');
            renderWorld(); // Force InstancedMesh to redraw
        }
    }

    function placeBlock() {
        const target = getMobileTarget();
        if (target && hotbar[selectedSlot]) {
            const nx = target.x + target.face.normal.x;
            const ny = target.y + target.face.normal.y;
            const nz = target.z + target.face.normal.z;

            if (!blockIntersectsPlayer(nx, ny, nz)) {
                startSwing();
                setBlockData(nx, ny, nz, hotbar[selectedSlot]);
                playSound('place');
                renderWorld(); // Force InstancedMesh to redraw
            }
        }
    }

    canvas.addEventListener('touchstart', e => {
        // track each new touch
        for (let t of e.changedTouches) {
            // ignore touches that began on UI (joystick/buttons)
            if (t.target.closest && t.target.closest('#mobile-ui')) continue;

            activeTouches[t.identifier] = {
                startX: t.clientX,
                startY: t.clientY,
                lastX: t.clientX,
                lastY: t.clientY,
                moved: false,
                holdTimer: setTimeout(() => {
                    // only break if this touch didn't start on UI and hasn't moved
                    breakBlock();
                    activeTouches[t.identifier] && (activeTouches[t.identifier].holdTimer = null);
                }, HOLD_MS)
            };
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        for (let t of e.changedTouches) {
            const rec = activeTouches[t.identifier];
            if (!rec) continue; // either UI touch or not tracked
            const dx = t.clientX - rec.lastX;
            const dy = t.clientY - rec.lastY;

            // if moved enough, consider it a swipe -> cancel hold timer and do look
            if (!rec.moved && (Math.abs(t.clientX - rec.startX) > 6 || Math.abs(t.clientY - rec.startY) > 6)) {
                rec.moved = true;
                if (rec.holdTimer) { clearTimeout(rec.holdTimer); rec.holdTimer = null; }
            }

            if (rec.moved) {
                // perform camera look
                player.yaw -= dx * 0.005;
                player.pitch = Math.max(-1.5, Math.min(1.5, player.pitch - dy * 0.005));
            }

            rec.lastX = t.clientX;
            rec.lastY = t.clientY;
        }

        // prevent page scroll
        e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        for (let t of e.changedTouches) {
            const rec = activeTouches[t.identifier];
            if (!rec) continue;

            // if it never moved and holdTimer still exists => treat as tap => place
            if (!rec.moved) {
                if (rec.holdTimer) {
                    clearTimeout(rec.holdTimer);
                    rec.holdTimer = null;
                    // short tap -> place
                    placeBlock();
                } else {
                    // holdTimer already fired and broke block; do nothing
                }
            }
            // cleanup
            if (rec.holdTimer) {
                clearTimeout(rec.holdTimer);
                rec.holdTimer = null;
            }
            delete activeTouches[t.identifier];
        }
    }, { passive: false });

    // Also prevent context menu or double-tap zoom interfering
    canvas.addEventListener('touchcancel', e => {
        for (let t of e.changedTouches) {
            const rec = activeTouches[t.identifier];
            if (rec && rec.holdTimer) clearTimeout(rec.holdTimer);
            delete activeTouches[t.identifier];
        }
    }, { passive: false });
}
/* ---------------------------
   End mobile input section
   --------------------------- */
// Store current world config globally
let currentWorldConfig = null;

setInterval(async () => {
    if (gameStarted && currentWorldId && currentWorldConfig) {
        // CRITICAL: Pull the current world data into the config object
        currentWorldConfig.blocks = { ...worldData }; 
        currentWorldConfig.playerPos = { x: player.x, y: player.y, z: player.z };
        
        await WorldManager.saveWorld(currentWorldId, currentWorldConfig);
        console.log('World auto-saved successfully');
    }
}, 30000);

// Save on page unload
window.addEventListener('beforeunload', async () => {
    if (gameStarted && currentWorldId && currentWorldConfig) {
        currentWorldConfig.blocks = worldData;
        await WorldManager.saveWorld(currentWorldId, currentWorldConfig);
    }
});
        let lastTime = performance.now();
function updateHighlight() {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    raycaster.set(camera.position, dir);

    // Instead of worldMeshes.values(), we check the instanced managers
    const meshesToCheck = Object.values(instancedMeshes);
    const hits = raycaster.intersectObjects(meshesToCheck);

    if (hits.length > 0 && hits[0].distance < 6) {
        const hit = hits[0];
        
        // Get the matrix of the specific instance we hit
        const matrix = new THREE.Matrix4();
        hit.object.getMatrixAt(hit.instanceId, matrix);
        
        // Extract the position from that matrix
        const position = new THREE.Vector3();
        position.setFromMatrixPosition(matrix);

        // Snap highlight perfectly to the block center
        // (Block coordinates are integers, we add 0.5 to center the 1x1 box)
        highlightMesh.position.set(
            Math.round(position.x) + 0.5, 
            Math.round(position.y) + 0.5, 
            Math.round(position.z) + 0.5
        ); 
        
        highlightMesh.scale.set(1.05, 1.05, 1.05); 
        highlightMesh.visible = true;
    } else {
        highlightMesh.visible = false;
    }
}
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            fpsFrames++;

if (now - fpsLastTime >= 1000) {
    fpsValue = fpsFrames;
    fpsFrames = 0;
    fpsLastTime = now;
    document.getElementById('fps').textContent = `FPS: ${fpsValue}`;
}

            const dt = Math.min((now - lastTime) / 1000, 0.1);
                const dt2 = (performance.now() - lastTime) / 1000;
            lastTime = now;
            if (gameStarted) {
    updatePlayer(dt);
    maybeUpdateWorld();
    updateHighlight(); // ← highlight
updateSwing(dt2);

    updateInfo();
            }



renderer.render(scene, camera);
}
                
    </script>
    
</body>
</html>

